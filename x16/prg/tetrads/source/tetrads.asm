;TETRADS (Commander X16 version)
;by David Murray 2022 dfwgreencars@gmail.com
;use ACME cross-compiler for this code.

!to "TETRADS.PRG",cbm
!cpu 65c02

*=$0801		;START ADDRESS IS $0801

VERA_L		=$9F20	;VERA setup VRAM access low-byte
VERA_M		=$9F21	;VERA setup VRAM access middle-byte
VERA_H		=$9F22	;VERA setup VRAM increment+high-byte
VERA_DATA	=$9F23	;Write data to VRAM
SOURCE_L	=$02	;for reading from a data source inderectly
SOURCE_H	=$03	;for reading from a data source inderectly
FIELD_WIDTH	=$04	;how wide is the playfield (usually 10 to 16)
LEFT_START	=$05	;left edge of playfield (defaults to 15)
AX		=$06	;These are the coordinates of the 4
BX		=$07	;sections of the brick
CX		=$08
DX		=$09
AY		=$0A
BY		=$0B
CY		=$0C
DY		=$0D
TYPE		=$0E	;what sort of brick is it (0 to 6)
BRICK_COLOR	=$0F	;what color is the brick
ROTATION	=$10	;current state of rotation
AXT		=$11	;These are the TEMPORARY coordinates of
BXT		=$12	;the 4 sections of the brick used for
CXT		=$13	;testing if a brick can move somewhere.
DXT		=$14
AYT		=$15
BYT		=$16
CYT		=$17
DYT		=$18
BGTIMER1	=$19	;used by IRQ timer routine
COUNTDOWN	=$1A	;used by IRQ timer routine
NEXT		=$1B	;stores next brick type
COUNTDOWN2	=$1C	;used by IRQ timer routine
COLOR		=$2D	;Color data read from data stream
REPEAT		=$2E	;number of repeats to use
STEP		=$2F	;step 0=first byte, step 1= second byte
OUTPUT		=$30	;data that will be sent to VERA
EOF		=$31	;1=end of file
SOURCE_BYTE	=$32	;used in decompression routine
GETIN		=$FFE4		;kernal call for get keyboard input
CHAROUT	=$FFD2		;kernal call for output character
BG_NUMBER	=$075D		;which background will be loaded
EOF_L		=$075E		;END OF FILE
EOF_H		=$075F
PROG		=$0760		;0=Constant 1=Progressive
DELAY		=$0761
CONTROL	=$0762		;0=keybaord 1=snes
START_LEVEL	=$0763
MUSIC_SCORE	=$0764
MUSIC_COUNT	=$0765
GAME_OVER_SET	=$0766		;1=game over situation
LEFT_OFFSET	=$0767
TX		=$0768
TY		=$0769
LINES_FOUND	=$076A
LINES_H	=$076B		;VALUES BCD
LINES_L	=$076C		;VALUES BCD
LINES_LEV	=$076D		;Counts up to 20 before level change	
SCORE_H	=$076E		;VALUES BCD
SCORE_M	=$076F		;VALUES BCD
SCORE_L	=$0770		;VALUES BCD
ELY		=$0771		;Variables used for line
DLY		=$0772		;deletion routines
RANDOM		=$0773		;used for random number generator
SNES_L		=$0774
SNES_H		=$0775
MUSIC_ON	=$0776		;0=OFF 1=OFF
CREDITS_TIMER	=$0777		;Time between credits changes
CREDITS_TIMER2=$0778		;which line to display	

!SOURCE	"ZSOUND.INC"

BASIC:	!BYTE $0B,$08,$01,$00,$9E,$32,$30,$36,$31,$00,$00,$00
		;Adds BASIC line:  1 SYS 2061
	JMP	STARTHERE

;It is required that zsound load in at $0810, because it is
;a pre-built binary compiled from C.  So, the binary is
;placed here in the source code, and as you can see there
;is a JMP command right before it to bypass it.  

!BINARY "ZSOUND.PRG"		;ZSsound program binary.

;pad 47 bytes for zsound variable space.
!BYTE	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
!BYTE	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

MUSIC_TITLE_FILENAME:
	!PET	"ingame0.zsm"
MUSIC_FILENAME:
	!PET	"ingame1.zsm"
SFX_FILENAME:
	!PET	"sounds.bin"
BG_FILENAME:
	!PET	"bg0.rle"
LOAD_MSG_TEXT:
	!PET	"tetrads version 1.0 by david murray",13
	!PET	"loading assets...",0

;This section handles some of the initial settings
;and procedures before we get to the main menu.

STARTHERE:
	JSR	LOAD_MSG
	LDA	#1
	STA	PROG
	STA	MUSIC_ON
	LDA	#0
	STA	START_LEVEL
	LDA	#1
	STA	MUSIC_SCORE
	JSR	LOAD_SFX
	JSR	LOAD_TITLE_MUSIC
	JSR	SETUP_VERA
	JSR	CLEAR_SCREEN
	JSR	LOAD_NEWCHARS
	JSR	ZSM_INIT
	JSR	PCM_INIT
	LDA	#15	;PCM VOLUME
	JSR	PCM_SET_VOLUME
	JSR	SETUP_INTERRUPT
	;SETUP BACKGROUND IMAGE	
	LDA	#6
	STA	$9F2D	;set layer 0 to bitmap mode 4BPP
	LDA	#16
	STA	$9F2F	;set base address for bitmap
	LDA	#10	;DEFAULT PLAYFIELD SIZE
	STA	FIELD_WIDTH
	JMP	MAIN_MENU

;This routine displays the starting message with
;version number.  
LOAD_MSG:
	LDX	#0
LMT0:	LDA	LOAD_MSG_TEXT,X
	CMP	#0
	BNE	LMT1	
	RTS
LMT1:	JSR	CHAROUT
	INX
	JMP	LMT0

START_GAME:
	LDA	#1
	STA	MUSIC_SCORE
	JSR	LOAD_GAME_MUSIC
	STZ	MUSIC_COUNT
	JSR	CLEAR_SCREEN
	;pause for a second
	LDA	#10
	STA	COUNTDOWN
STG1:	LDA	COUNTDOWN
	CMP	#0
	BNE	STG1
	;pause over
	JSR	ZSM_STOP
	LDA	#1
	STA	BG_NUMBER
	JSR	LOAD_PICTURE
	JSR	DISPLAY_IMAGE
	;pause for a second
	LDA	#30
	STA	COUNTDOWN
STG2:	LDA	COUNTDOWN
	CMP	#0
	BNE	STG2	
	;pause over
	STZ	SCORE_L
	STZ	SCORE_M
	STZ	SCORE_H
	STZ	LINES_L
	STZ	LINES_H
	STZ	LINES_LEV
	STZ	GAME_OVER_SET
	JSR	SET_PLAYFIELD_SIZE
	JSR	CLEAR_PLAYFIELD
	JSR	SETUP_NEXT_AREA	
	JSR	SETUP_SCORE_AREA
	JSR	DISPLAY_LINES_CLEARED
	JSR	GENERATE_RANDOM_BRICK
	STA	NEXT
	JSR	ANIMATE_SCREEN_OPENING
	JSR	DISPLAY_NEXT_BRICK
	JSR	INIT_NEW_BLOCK
	JSR	SET_DELAY
	LDA	DELAY
	STA	COUNTDOWN
	JSR	START_GAME_MUSIC
	JMP	GAME_LOOP

SET_DELAY:
	LDX	START_LEVEL
	LDA	DELAY_CHART,X
	STA	DELAY
	RTS
DELAY_CHART	!BYTE 60,55,50,45,40,35,30,25,20,15,10,5

START_GAME_MUSIC:
	LDA	MUSIC_ON
	CMP	#1
	BEQ	SGM1
	RTS
SGM1:	;Music is enabled, so pick the
	;correct song and start playing
	LDA	#12
	LDY	#$BA
	LDX	#$90
	JSR	ZSM_START

	RTS

;This routine runs one-time and sets up the IRQ routine so that
;it will call RUNIRQ regularly. 
SETUP_INTERRUPT:
	SEI			; Disable interrupt routine
	LDA	$0314		; get old address
	STA	IRQ32+1
	LDA	$0315		; get old address
	STA	IRQ32+2
	LDA	#<RUNIRQ	; Setup IRQ to visit my routine RUNIRQ before
	STA	$0314		; doing the usual IRQ routine.
	LDA	#>RUNIRQ
	STA	$0315
	CLI			; Reenable routine.
	RTS

;This is the routine that runs 60 times per second from the IRQ.
;BGTIMER1 is always set to 1 every cycle, after which the main
;program will reset it to 0 when it is done with it's work for
;that cycle.  COUNTDOWN is a count-down to zero and then stays
;there.
RUNIRQ:
	JSR	PCM_PLAY	;Zsound PCM routine (must come first)
	JSR	ZSM_PLAYIRQ	;Zsound music routine.
	LDA	#1
	STA	BGTIMER1
	;Do first countdown timer
	LDA	COUNTDOWN
	CMP	#0
	BEQ	IRQ31
	DEC	COUNTDOWN
	;Do second countdown timer
IRQ31:	LDA	COUNTDOWN2
	CMP	#0
	BEQ	IRQ32
	DEC	COUNTDOWN2
IRQ32:	JMP	$EA31		; Back to usual IRQ routine


;This is the main routine for checking the keyboard or 
;SNES controller and keeping the game running while
;waiting on user input.
GAME_LOOP:
	LDA	GAME_OVER_SET
	CMP	#0
	BEQ	GL0
	JMP	GAME_OVER
GL0:	INC	RANDOM
	LDA	COUNTDOWN
	CMP	#0
	BNE	GL1
	JSR	MOVE_DOWN
	JMP	GAME_LOOP
GL1:	LDA	CONTROL
	CMP	#0
	BEQ	GL2
	JMP	SNES_CONTROL
GL2:	JSR	GETIN
	CMP	#0
	BEQ	GAME_LOOP
	CMP	#$11	;CURSOR DOWN
	BNE 	GL5
	JSR	MOVE_DOWN
	JMP	GAME_LOOP
GL5:	CMP	#$9D	;CURSOR LEFT
	BNE	GL6
	JSR	MOVE_LEFT
	JMP	GAME_LOOP
GL6:	CMP	#$1D	;CURSOR RIGHT
	BNE	GL7
	JSR	MOVE_RIGHT
	JMP	GAME_LOOP
GL7:	CMP	#90	;Z-KEY
	BNE	GL8
	JSR	ROTATE_LEFT
	JMP	GAME_LOOP
GL8: 	CMP	#88	;X-KEY
	BNE	GL9
	JSR	ROTATE_RIGHT
	JMP	GAME_LOOP
GL9:	CMP	#27	;ESC KEY
	BNE	GL10
	JSR	PLAY_MENU_SELECT
	JMP	GAME_OVER
GL10:	CMP	#3	;RUNSTOP
	BNE	GL11
	JSR	PLAY_MENU_SELECT
	JMP	GAME_OVER
GL11:	CMP	#13	;RETURN
	BNE	GL12
	JSR	PAUSE_GAME
	JMP	GAME_LOOP
GL12:	CMP	#32	;SPACE
	BNE	GL13
	JSR	DROP_PIECE
GL13:	JMP	GAME_LOOP

SNES_CONTROL:
	LDA	COUNTDOWN2
	CMP	#0
	BEQ	SNE2
	JMP	GAME_LOOP
SNE2:	LDA	#1		;JOY 1
	JSR	$FF56		;JOYSTICK GET
	STA	SNES_L
	STX	SNES_H
	AND	#%00000010	;DPAD-LEFT
	CMP	#%00000000
	BNE	SNE3
	JSR	MOVE_LEFT
	LDA	#8
	STA	COUNTDOWN2
SNE3:	LDA	SNES_L
	AND	#%00000001	;DPAD-RIGHT
	CMP	#%00000000
	BNE	SNE4
	JSR	MOVE_RIGHT
	LDA	#8
	STA	COUNTDOWN2
SNE4:	LDA	SNES_L
	AND	#%00000100	;DPAD-DOWN
	CMP	#%00000000
	BNE	SNE5
	JSR	MOVE_DOWN
	LDA	#5
	STA	COUNTDOWN2
	JMP	GAME_LOOP
SNE5:	LDA	SNES_L
	AND	#%10000000	;B-BUTTON
	CMP	#%00000000
	BNE	SNE6
	JSR	ROTATE_RIGHT
	LDA	#12
	STA	COUNTDOWN2
	JMP	GAME_LOOP
SNE6:	LDA	SNES_L
	AND	#%01000000	;Y-BUTTON
	CMP	#%00000000
	BNE	SNE7
	JSR	ROTATE_LEFT
	LDA	#12
	STA	COUNTDOWN2
	JMP	GAME_LOOP
SNE7:	LDA	SNES_L
	AND	#%00110000	;START+SELECT
	CMP	#%00000000
	BNE	SNE8
	JMP	GAME_OVER
SNE8:	LDA	SNES_L
	AND	#%00010000	;START
	CMP	#%00000000
	BNE	SNE9
	JSR	PAUSE_GAME
	LDA	#11
	STA	COUNTDOWN2
SNE9:	LDA	SNES_H
	AND	#%01000000	;x BUTTON
	CMP	#%00000000
	BNE	SNE10
	JSR	DROP_PIECE
	LDA	#10
	STA	COUNTDOWN2
SNE10:	JMP	GAME_LOOP	

DROP_PIECE:
	LDA	#1
	STA	DROP_FLAG
DP0:	LDA	#1
	STA	COUNTDOWN
DP1:	LDA	COUNTDOWN
	CMP	#0
	BNE	DP1
	JSR	MOVE_DOWN
	LDA	DROP_FLAG
	CMP	#1
	BEQ	DP0
	RTS
DROP_FLAG	!BYTE 0

ROTATE_LEFT:
	JSR	ROTATE_BACKWARD
	;First calculate chart position
	LDX	ROTATION
	LDA	ROCHT,X
	CLC
	ADC	TYPE
	TAX
	;now do first piece
	LDA	ROTATION_AX,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	AX
	SEC
	SBC	#2
	STA	AXT
	LDA	ROTATION_AY,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	AY
	SEC
	SBC	#2
	STA	AYT
	;now do second piece
	LDA	ROTATION_BX,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	BX
	SEC
	SBC	#2
	STA	BXT
	LDA	ROTATION_BY,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	BY
	SEC
	SBC	#2
	STA	BYT
	;now do third piece
	LDA	ROTATION_CX,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	CX
	SEC
	SBC	#2
	STA	CXT
	LDA	ROTATION_CY,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	CY
	SEC
	SBC	#2
	STA	CYT
	;now do fourth piece
	LDA	ROTATION_DX,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	DX
	SEC
	SBC	#2
	STA	DXT
	LDA	ROTATION_DY,X
	TAY
	LDA	INVERSION,Y
	CLC
	ADC	DY
	SEC
	SBC	#2
	STA	DYT
	;Virtual rotation finished, now see if it
	;has hit anything
	JSR	VALIDATE
	CMP	#1
	BEQ	RL5
	JSR	PLAY_ROTATE_LEFT
	JSR	XFER_BRICK
	RTS
RL5:	JSR	ROTATE_FORWARD
	RTS

;this table gives us the opposite of what the movements
;would usually be, so we can rotate backwards.
INVERSION	!BYTE 4,3,2,1,0

ROTATE_RIGHT:
	;First calculate chart position
	LDX	ROTATION
	LDA	ROCHT,X
	CLC
	ADC	TYPE
	TAX
	;now do first piece
	LDA	ROTATION_AX,X
	CLC
	ADC	AX
	SEC
	SBC	#2
	STA	AXT
	LDA	ROTATION_AY,X
	CLC
	ADC	AY
	SEC
	SBC	#2
	STA	AYT
	;now do second piece
	LDA	ROTATION_BX,X
	CLC
	ADC	BX
	SEC
	SBC	#2
	STA	BXT
	LDA	ROTATION_BY,X
	CLC
	ADC	BY
	SEC
	SBC	#2
	STA	BYT
	;now do third piece
	LDA	ROTATION_CX,X
	CLC
	ADC	CX
	SEC
	SBC	#2
	STA	CXT
	LDA	ROTATION_CY,X
	CLC
	ADC	CY
	SEC
	SBC	#2
	STA	CYT
	;now do fourth piece
	LDA	ROTATION_DX,X
	CLC
	ADC	DX
	SEC
	SBC	#2
	STA	DXT
	LDA	ROTATION_DY,X
	CLC
	ADC	DY
	SEC
	SBC	#2
	STA	DYT
	;finished virtual rotation, now check for
	;any pieces that could be out-of-bounds
	JSR	VALIDATE
	CMP	#1
	BEQ	RR5
	;all is good, commit the change.
	JSR	PLAY_ROTATE_RIGHT
	JSR	ROTATE_FORWARD
	JSR	XFER_BRICK
RR5:	RTS
ROCHT	!BYTE 0,7,14,21

;This routine looks at the virtual placement
;of the piece after roation/movement and determines
;if it has collided with anything or left the edge
;of the playfield.
VALIDATE:
	;First validate against left/right edges
	LDA	AXT
	CMP	FIELD_WIDTH
	BCC	VAL2
	LDA	#1
	RTS
VAL2:	LDA	BXT
	CMP	FIELD_WIDTH
	BCC	VAL3
	LDA	#1
	RTS
VAL3:	LDA	CXT
	CMP	FIELD_WIDTH
	BCC	VAL4
	LDA	#1
	RTS
VAL4:	LDA	DXT
	CMP	FIELD_WIDTH
	BCC	VAL5
	LDA	#1
	RTS
VAL5:	;Now validate against bottom edge
	LDA	AYT
	CMP	#20
	BCC	VAL6
	LDA	#1
	RTS
VAL6:	LDA	BYT
	CMP	#20
	BCC	VAL7
	LDA	#1
	RTS
VAL7:	LDA	CYT
	CMP	#20
	BCC	VAL8
	LDA	#1
	RTS
VAL8:	LDA	DYT
	CMP	#20
	BCC	VAL9
	LDA	#1
	RTS
VAL9:	;Now validate against other bricks
	LDA	AXT
	STA	TX
	LDA	AYT
	STA	TY	
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	VAL10
	LDA	#1
	RTS
VAL10:	LDA	BXT
	STA	TX
	LDA	BYT
	STA	TY	
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	VAL11
	LDA	#1
	RTS
VAL11:	LDA	CXT
	STA	TX
	LDA	CYT
	STA	TY	
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	VAL12
	LDA	#1
	RTS
VAL12:	LDA	DXT
	STA	TX
	LDA	DYT
	STA	TY	
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	VAL13
	LDA	#1
	RTS
VAL13:
	LDA	#0	;no collisions found
	RTS

;This routine transfers a virtual brick to
;a real brick.
XFER_BRICK:
	JSR	ERASE_BRICK
	LDA	AXT
	STA	AX
	LDA	AYT
	STA	AY
	LDA	BXT
	STA	BX
	LDA	BYT
	STA	BY
	LDA	CXT
	STA	CX
	LDA	CYT
	STA	CY
	LDA	DXT
	STA	DX
	LDA	DYT
	STA	DY
	JSR	DRAW_BRICK
	RTS

ROTATE_FORWARD:
	INC	ROTATION
	LDA	ROTATION
	CMP	#4
	BNE	FR1
	STZ	ROTATION
FR1:	RTS

ROTATE_BACKWARD:
	LDA	ROTATION
	CMP	#0
	BEQ	RTL1
	DEC	ROTATION
	JMP	RTL2
RTL1:	LDA	#3
	STA	ROTATION
RTL2:	RTS

MOVE_LEFT:
	LDA	AX
	CMP	#0
	BNE	ML1
	RTS
ML1:	LDA	BX
	CMP	#0
	BNE	ML2
	RTS
ML2:	LDA	CX
	CMP	#0
	BNE	ML3
	RTS
ML3:	LDA	DX
	CMP	#0
	BNE	ML4
	RTS	
ML4:	;now check if any pieces are in the way.
	LDA	AX
	DEC
	STA	TX
	LDA	AY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	ML10
	RTS
ML10:	LDA	BX
	DEC
	STA	TX
	LDA	BY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	ML11
	RTS
ML11:	LDA	CX
	DEC
	STA	TX
	LDA	CY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	ML12
	RTS
ML12:	LDA	DX
	DEC
	STA	TX
	LDA	DY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	ML13
	RTS
	;now move brick
ML13:	;JSR	PLAY_MENU_BEEP
	JSR	ERASE_BRICK
	DEC	AX
	DEC	BX
	DEC	CX
	DEC	DX
	JSR	DRAW_BRICK	
	RTS

MOVE_RIGHT:
	;First check that brick isn't at far right edge
	LDA	AX
	INC
	CMP	FIELD_WIDTH
	BNE	MR1
	RTS
MR1:	LDA	BX
	INC
	CMP	FIELD_WIDTH
	BNE	MR2
	RTS
MR2:	LDA	CX
	INC
	CMP	FIELD_WIDTH
	BNE	MR3
	RTS
MR3:	LDA	DX
	INC
	CMP	FIELD_WIDTH
	BNE	MR4
	RTS	
MR4:	;now check if any pieces are in the way.
	LDA	AX
	INC
	STA	TX
	LDA	AY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MR10
	RTS
MR10:	LDA	BX
	INC
	STA	TX
	LDA	BY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MR11
	RTS
MR11:	LDA	CX
	INC
	STA	TX
	LDA	CY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MR12
	RTS
MR12:	LDA	DX
	INC
	STA	TX
	LDA	DY
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MR13
	RTS
	;now move brick
MR13:	;JSR	PLAY_MENU_BEEP
	JSR	ERASE_BRICK
	INC	AX
	INC	BX
	INC	CX
	INC	DX
	JSR	DRAW_BRICK	
	RTS

MOVE_DOWN:
	;reset wait period for automatic down movement.
	LDA	DELAY
	STA	COUNTDOWN
	;First check to see if we have hit the botom
	;of the playfield
	LDA	AY
	CMP	#19
	BNE	MD1
	JMP	MDSTOP
MD1:	LDA	BY
	CMP	#19
	BNE	MD2
	JMP	MDSTOP
MD2:	LDA	CY
	CMP	#19
	BNE	MD3
	JMP	MDSTOP
MD3:	LDA	DY
	CMP	#19
	BNE	MD4
	JMP	MDSTOP
MD4:	;Now check to see if any previos bricks
	;are in the way.
	LDA	AX
	STA	TX
	LDA	AY
	INC
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MD10
	JMP	MDSTOP
MD10:	LDA	BX
	STA	TX
	LDA	BY
	INC
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MD11
	JMP	MDSTOP
MD11:	LDA	CX
	STA	TX
	LDA	CY
	INC
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MD12
	JMP	MDSTOP
MD12:	LDA	DX
	STA	TX
	LDA	DY
	INC
	STA	TY
	JSR	READ_FROM_BUFFER
	CMP	#$AA
	BEQ	MD13
	JMP	MDSTOP
MD13:	;go ahead and move brick down
	JSR	ERASE_BRICK
	INC	AY
	INC	BY
	INC	CY
	INC	DY
	JSR	DRAW_BRICK	
	RTS
	;Block has reached the bottom.
MDSTOP:
	JSR	COPY_BRICK_TO_BUFFER
	JSR	SCAN_FOR_COMPLETED_LINES
	LDA	LINES_FOUND
	CMP	#0
	BEQ	PAS0
	JSR	ELIMINATE_LINES
	JSR	INCREASE_LEVEL
	;increase the score by 1
PAS0:	SED
	LDA	SCORE_L
	CLC
	ADC	#1
	STA	SCORE_L
	LDA	SCORE_M
	ADC	#0
	STA	SCORE_M
	LDA	SCORE_H
	ADC	#0
	STA	SCORE_H
	CLD
	JSR	DISPLAY_LINES_CLEARED
	LDA	#10
	STA	COUNTDOWN
PAS1:	LDA	COUNTDOWN	;Pause for 10 cycles
	CMP	#0
	BNE	PAS1
	JSR 	INIT_NEW_BLOCK
	JSR	CLEAR_KEYBOARD_BUFFER
	STZ	DROP_FLAG
	RTS

SETUP_NEXT_AREA:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$B5
	STA	VERA_M
	LDA	#58
	STA	VERA_L
	LDY	#0
	STY	TY	
	LDX	#0
DNA0:	LDY	#0
DNA1:	LDA	NEXT_AREA_DATA,X
	STA	VERA_DATA
	CMP	#128
	BEQ	DNA4
	CMP	#135
	BEQ	DNA2
	LDA	#$AC	;gray on black
	JMP	DNA3
DNA4:	LDA	#$A1	;white on black
	JMP	DNA3
DNA2:	LDA	#$AA	;black on black
DNA3:	STA	VERA_DATA
	INX
	INY
	CPY	#6
	BNE	DNA1
	INC	VERA_M
	LDA	#58
	STA	VERA_L
	INC	TY
	LDA	TY
	CMP	#5
	BNE	DNA0		
	RTS

SETUP_SCORE_AREA:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$B5
	STA	VERA_M
	LDA	#8
	STA	VERA_L
	LDY	#0
	STY	TY	
	LDX	#0
SCA0:	LDY	#0
SCA1:	LDA	SCORE_AREA_DATA,X
	STA	VERA_DATA
	CMP	#128
	BEQ	SCA4
	CMP	#135
	BEQ	SCA2
	LDA	#$AC	;gray on black
	JMP	SCA3
SCA4:	LDA	#$A1	;white on black
	JMP	SCA3
SCA2:	LDA	#$AA	;black on black
SCA3:	STA	VERA_DATA
	INX
	INY
	CPY	#7
	BNE	SCA1
	INC	VERA_M
	LDA	#8
	STA	VERA_L
	INC	TY
	LDA	TY
	CMP	#6
	BNE	SCA0		
	RTS
	
DISPLAY_LINES_CLEARED:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$B9
	STA	VERA_M
	LDA	#12
	STA	VERA_L
	;First digit
	LDA	LINES_H
	LSR
	LSR
	LSR
	LSR
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;Second digit
	LDA	LINES_H
	AND	#%00001111
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;third digit
	LDA	LINES_L
	LSR
	LSR
	LSR
	LSR
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;Fourth digit
	LDA	LINES_L
	AND	#%00001111
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;Now display score
	LDA	#$B7
	STA	VERA_M
	LDA	#10
	STA	VERA_L
	;VERY High digit
	LDA	SCORE_H
	AND	#%00001111
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;First digit
	LDA	SCORE_M
	LSR
	LSR
	LSR
	LSR
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;Second digit
	LDA	SCORE_M
	AND	#%00001111
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;third digit
	LDA	SCORE_L
	LSR
	LSR
	LSR
	LSR
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	;Fourth digit
	LDA	SCORE_L
	AND	#%00001111
	TAX
	LDA	HEXCHART,X
	STA	VERA_DATA
	LDA	#$A1
	STA	VERA_DATA
	RTS
HEXCHART	!SCR "0123456789abcdef"

DISPLAY_NEXT_BRICK:
	JSR	SETUP_NEXT_AREA
	LDA	#%00000001
	STA	VERA_H
	;Do part 1 of 4
	LDX	NEXT
	LDA	BRICK_CHART_AY,X
	CLC
	ADC	#$B7
	STA	VERA_M
	LDA	BRICK_CHART_AX,X
	ASL	;mult by 2
	CLC
	ADC	#61
	STA	VERA_L
	LDA	BRICK_CHART_COLOR,X
	STA	VERA_DATA
	;Do part 2 of 4
	LDX	NEXT
	LDA	BRICK_CHART_BY,X
	CLC
	ADC	#$B7
	STA	VERA_M
	LDA	BRICK_CHART_BX,X
	ASL	;mult by 2
	CLC
	ADC	#61
	STA	VERA_L
	LDA	BRICK_CHART_COLOR,X
	STA	VERA_DATA
	;Do part 3 of 4
	LDX	NEXT
	LDA	BRICK_CHART_CY,X
	CLC
	ADC	#$B7
	STA	VERA_M
	LDA	BRICK_CHART_CX,X
	ASL	;mult by 2
	CLC
	ADC	#61
	STA	VERA_L
	LDA	BRICK_CHART_COLOR,X
	STA	VERA_DATA
	;Do part 4 of 4
	LDX	NEXT
	LDA	BRICK_CHART_DY,X
	CLC
	ADC	#$B7
	STA	VERA_M
	LDA	BRICK_CHART_DX,X
	ASL	;mult by 2
	CLC
	ADC	#61
	STA	VERA_L
	LDA	BRICK_CHART_COLOR,X
	STA	VERA_DATA
	RTS

GENERATE_RANDOM_BRICK:
INB1:	JSR	GENERATE_RANDOM_NUMBER
	LDA	RANDOM
	AND	#%00000111
	CMP	#7
	BEQ	INB1
	RTS

INIT_NEW_BLOCK:
	LDA	NEXT
	STA	TYPE
	JSR	GENERATE_RANDOM_BRICK
	;LDA	#0	;i_piece for cheating
	STA	NEXT
	JSR	DISPLAY_NEXT_BRICK
	STZ	ROTATION
	;calculate center offset
INB2:	LDA	FIELD_WIDTH
	SEC
	SBC	#4
	LSR	;DIVIDE BY TWO
	STA	LEFT_OFFSET
	LDX	TYPE
	LDA	BRICK_CHART_AX,X
	CLC
	ADC	LEFT_OFFSET
	STA	AX
	LDA	BRICK_CHART_BX,X
	CLC
	ADC	LEFT_OFFSET
	STA	BX
	LDA	BRICK_CHART_CX,X
	CLC
	ADC	LEFT_OFFSET
	STA	CX
	LDA	BRICK_CHART_DX,X
	CLC
	ADC	LEFT_OFFSET
	STA	DX
	LDA	BRICK_CHART_AY,X
	STA	AY
	LDA	BRICK_CHART_BY,X
	STA	BY
	LDA	BRICK_CHART_CY,X
	STA	CY
	LDA	BRICK_CHART_DY,X
	STA	DY
	LDA	BRICK_CHART_COLOR,X
	STA	BRICK_COLOR
	JSR	DRAW_BRICK
	;now see if we hit game-over
	LDA	AX
	STA	AXT
	LDA	BX
	STA	BXT
	LDA	CX
	STA	CXT
	LDA	DX
	STA	DXT
	LDA	AY
	STA	AYT
	LDA	BY
	STA	BYT
	LDA	CY
	STA	CYT
	LDA	DY
	STA	DYT
	JSR	VAL9
	CMP	#1	;0=no collision 1=collision
	BNE	INB3
	STA	GAME_OVER_SET
INB3:	LDA	DELAY
	STA	COUNTDOWN
	RTS

ERASE_BRICK:
	LDA	#$AA
	STA	BRICK_COLOR
	JSR	DRAW_BRICK
	LDX	TYPE
	LDA	BRICK_CHART_COLOR,X
	STA	BRICK_COLOR
	RTS

DRAW_BRICK:
	LDA	#%00000001
	STA	VERA_H
	;Do part 1 of 4
	LDA	AY
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	AX
	ASL	;multiply by 2
	CLC
	ADC	LEFT_START
	INC
	STA	VERA_L
	LDA	BRICK_COLOR
	STA	VERA_DATA	
	;Do part 2 of 4
	LDA	BY
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	BX
	ASL	;multiply by 2
	CLC
	ADC	LEFT_START
	INC
	STA	VERA_L
	LDA	BRICK_COLOR
	STA	VERA_DATA
	;Do part 3 of 4
	LDA	CY
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	CX
	ASL	;multiply by 2
	CLC
	ADC	LEFT_START
	INC
	STA	VERA_L
	LDA	BRICK_COLOR
	STA	VERA_DATA
	;Do part 4 of 4
	LDA	DY
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	DX
	ASL	;multiply by 2
	CLC
	ADC	LEFT_START
	INC
	STA	VERA_L
	LDA	BRICK_COLOR
	STA	VERA_DATA
	RTS

COPY_BRICK_TO_BUFFER:
	LDA	AX
	STA	TX
	LDA	AY
	STA	TY
	JSR	WRITE_TO_BUFFER
	LDA	BX
	STA	TX
	LDA	BY
	STA	TY
	JSR	WRITE_TO_BUFFER
	LDA	CX
	STA	TX
	LDA	CY
	STA	TY
	JSR	WRITE_TO_BUFFER
	LDA	DX
	STA	TX
	LDA	DY
	STA	TY
	JSR	WRITE_TO_BUFFER
	RTS

;This routine writes to the playfield buffer
;but setting TX and TY
WRITE_TO_BUFFER:
	LDA	TY
	STA	SOURCE_L
	LDA	#0
	STA	$03
	;multiply by 16 by shifting 4 times to left.
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	;now add offset for mapnames
	LDA	SOURCE_L
	CLC
	ADC	#<PLAYFIELD
	STA	SOURCE_L
	LDA	SOURCE_H
	ADC	#>PLAYFIELD
	STA	SOURCE_H
WTB1:	LDY	TX
	LDA	BRICK_COLOR
	STA	(SOURCE_L),Y
	RTS


;This routine reads data from the buffer.
;TX and TY must be set first.  The data
;is returned in TX
READ_FROM_BUFFER:
	JSR	SET_LINE_SOURCE
	LDY	TX
	LDA	(SOURCE_L),Y
	RTS


;This routine checks to see if 20 lines have
;been cleared since the last time the level
;was increased.  If so, it increases to the next
;level which means increasing speed, swapping
;background graphics and music.
INCREASE_LEVEL:
	LDA	LINES_LEV
	CMP	#20
	BCS	INL0
	RTS
INL0:	STZ	LINES_LEV
	INC	BG_NUMBER
	LDA	BG_NUMBER
	CMP	#10	;max number of images in library
	BNE	INL1
	LDA	#1
	STA	BG_NUMBER
INL1:	JSR	LOAD_PICTURE
	;Disable screen layers
	LDA	$9F29
	AND	#%00100011
	;ORA	#%00110000
	STA	$9F29
	JSR	DISP2
	;Adjust speed of falling bricks
	LDA	PROG
	CMP	#0
	BEQ	INL3
	LDA	DELAY
	CMP	#5
	BEQ	INL3
	LDA	DELAY
	SEC
	SBC	#5
	STA	DELAY
INL3:	;Now change musical scores
	LDA	MUSIC_ON
	CMP	#0
	BEQ	INL6
	LDA	MUSIC_COUNT
	CMP	#1
	BEQ	INL4
	LDA	#1
	STA	MUSIC_COUNT
	RTS	
INL4:	STZ	MUSIC_COUNT
	INC	MUSIC_SCORE
	LDA	MUSIC_SCORE
	CMP	#6	;max number of songs
	BNE	INL5
	LDA	#1
	STA	MUSIC_SCORE
INL5	JSR	ZSM_STOP
	JSR	LOAD_GAME_MUSIC
	LDA	#12
	LDY	#$BA
	LDX	#$90
	JSR	ZSM_START
INL6:	RTS


;This copies the entire playfield from
;the buffer to the actual screen.  Typically
;used when removing completed lines.
COPY_BUFFER_TO_SCREEN:
	LDA	#<PLAYFIELD
	STA	SOURCE_L
	LDA	#>PLAYFIELD
	STA	SOURCE_H
	LDA	#%00010001
	STA	VERA_H
	LDX	#0
CB0:	TXA
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	LEFT_START
	STA	VERA_L
	LDY	#0
CB1:	LDA	#135	;BLOCK CHAR
	STA	VERA_DATA
	LDA	(SOURCE_L),Y
	STA	VERA_DATA
	INY
	CPY	FIELD_WIDTH
	BNE	CB1
	LDA	SOURCE_L
	CLC
	ADC	#16
	STA	SOURCE_L
	LDA	SOURCE_H
	ADC	#0
	STA	SOURCE_H
	INX
	CPX	#20
	BNE	CB0
	RTS

SET_LINE_SOURCE:
	LDA	TY
	STA	SOURCE_L
	LDA	#0
	STA	$03
	;multiply by 16 by shifting 4 times to left.
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	ASL	SOURCE_L
	ROL	SOURCE_H
	;now add offset for mapnames
	LDA	SOURCE_L
	CLC
	ADC	#<PLAYFIELD
	STA	SOURCE_L
	LDA	SOURCE_H
	ADC	#>PLAYFIELD
	STA	SOURCE_H
	RTS
 
;This routine's only job is to look at 
;the playfield buffer and identify
;any completed lines and turn them
;gray (color #15)
SCAN_FOR_COMPLETED_LINES:
	STZ	LINES_FOUND
	STZ	TY
	;Find vertical starting position for current line.
	;and store it in SOURCE_L/SOURCE_H.
SFC1:	JSR	SET_LINE_SOURCE
	;Now check the line horizontally
	LDY	#0
SFC4:	LDA	(SOURCE_L),Y
	CMP	#$AA
	BEQ	SFC10
	INY
	CPY	FIELD_WIDTH
	BNE	SFC4
	;line is complete, mark it gray.
	INC	LINES_FOUND
SFC6:	LDY	#0
SFC5:	LDA	#$AF	;gray
	STA	(SOURCE_L),Y
	INY
	CPY	FIELD_WIDTH
	BNE	SFC5
SFC10:	INC	TY
	LDA	TY
	CMP	#20
	BNE	SFC1
	LDA	LINES_FOUND
	CMP	#0
	BEQ	SFC11
	JSR	COPY_BUFFER_TO_SCREEN
	JSR	ANIMATE_LINES
	JMP	SFC12
SFC11:	;play sound
	JSR	PLAY_LAY_BRICK
	;Add lines to running total.
SFC12:	SED
	LDA	LINES_L
	CLC
	ADC	LINES_FOUND
	STA	LINES_L
	LDA	LINES_H
	ADC	#0
	STA	LINES_H
	;now increase the score
	LDA	LINES_FOUND
	TAX
	LDA	SCORE_CHART,X
	CLC	
	ADC	SCORE_L
	STA	SCORE_L
	LDA	SCORE_M
	ADC	#0
	STA	SCORE_M
	LDA	SCORE_H
	ADC	#0
	STA	SCORE_H
	CLD	
	;Now add lines to level-counter
	LDA	LINES_FOUND
	CLC
	ADC	LINES_LEV
	STA	LINES_LEV
	RTS

SCORE_CHART	!BYTE $00,$10,$20,$50,$90	;values in BCD

;This routine flashes the line(s) to be
;deleted by altering the palette color
ANIMATE_LINES:
	;START SOUND PLAYING
	JSR	PLAY_CLEAR_LINE
	;now animate
	LDA	#%00010001
	STA	VERA_H
	LDA	#$FA
	STA	VERA_M
	LDY	#0
AL02:	STZ	BGTIMER1
AL03:	LDA	BGTIMER1
	CMP	#1
	BNE	AL03
	LDA	#30
	STA	VERA_L
	LDA	FLASH_DATA,Y
	STA	VERA_DATA
	INY
	LDA	FLASH_DATA,Y
	STA	VERA_DATA
	INY
	CPY	#38
	BNE	AL02
	LDA	#10
	STA	COUNTDOWN
AL04:	LDA	COUNTDOWN
	CMP	#0
	BNE	AL04
	RTS

FLASH_DATA:
	!BYTE $99,$09
	!BYTE $BB,$0B
	!BYTE $DD,$0D
	!BYTE $FF,$0F
	!BYTE $EE,$0E
	!BYTE $DD,$0D
	!BYTE $CC,$0C
	!BYTE $BB,$0B
	!BYTE $AA,$0A
	!BYTE $99,$09
	!BYTE $88,$08
	!BYTE $77,$07
	!BYTE $66,$06
	!BYTE $55,$05
	!BYTE $44,$04
	!BYTE $33,$03
	!BYTE $22,$02
	!BYTE $11,$01
	!BYTE $00,$00

RESET_PALETTE_GRAY:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$FA
	STA	VERA_M
	LDA	#30
	STA	VERA_L
	LDA	#$77
	STA	VERA_DATA
	LDA	#$07
	STA	VERA_DATA
	RTS

;This routine looks for lines colored white
;and eliminates them by pulling all of the 
;brick pieces above down.
ELIMINATE_LINES:
	LDA	#19
	STA	ELY
ELI5:	;check lines for gray
	LDA	ELY
	STA	TY
	JSR	SET_LINE_SOURCE
	LDY	#0
	LDA	(SOURCE_L),Y
	CMP	#$AF
	BNE	ELI6
	JSR	DELETE_CURRENT_LINE
	JMP	ELI5
ELI6:	DEC	ELY
	LDA	ELY
	CMP	#1
	BEQ	ELI10
	JMP	ELI5
ELI10:	;Now clear top line
	LDX	#0
	LDA	#$AA
ELI11:	STA	PLAYFIELD,X
	INX
	CPX	#16
	BNE	ELI11
	JSR	RESET_PALETTE_GRAY
	JSR	COPY_BUFFER_TO_SCREEN
	RTS

DELETE_CURRENT_LINE:
	LDA	ELY
	DEC
	STA	DLY
	
DCL5:	LDA	DLY
	STA	TY
	JSR	READ_CURRENT_LINE
	INC	TY
	JSR	WRITE_CURRENT_LINE
	LDA	DLY
	CMP	#0
	BEQ	DCL6
	DEC	DLY
	JMP	DCL5
DCL6:	RTS

READ_CURRENT_LINE:
	JSR	SET_LINE_SOURCE
	LDY	#0
SCL5:	LDA	(SOURCE_L),Y
	STA	LINE_BUFFER,Y
	INY
	CPY	#16
	BNE	SCL5
	RTS

WRITE_CURRENT_LINE:
	JSR	SET_LINE_SOURCE
	LDY	#0
WCL5:	LDA	LINE_BUFFER,Y
	STA	(SOURCE_L),Y
	INY
	CPY	#16
	BNE	WCL5
	RTS


LINE_BUFFER	!BYTE 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

CLEAR_KEYBOARD_BUFFER:
	JSR	GETIN
	CMP	#0
	BNE	CLEAR_KEYBOARD_BUFFER
	RTS

;These charts contain the default 
;configuration of each brick.
BRICK_CHART_AX:
	!BYTE	0	;I-piece 1 X	
	!BYTE	0	;J-piece 1 X
	!BYTE	2	;L-piece 1 X
	!BYTE	1	;O-piece 1 X
	!BYTE	1	;S-piece 1 X
	!BYTE	1	;T-piece 1 X
	!BYTE	0	;Z-piece 1 X
BRICK_CHART_AY:
	!BYTE	1	;I-piece 1 Y	
	!BYTE	0	;J-piece 1 Y
	!BYTE	0	;L-piece 1 Y
	!BYTE	0	;O-piece 1 Y
	!BYTE	0	;S-piece 1 Y
	!BYTE	0	;T-piece 1 Y
	!BYTE	0	;Z-piece 1 Y
BRICK_CHART_BX:
	!BYTE	1	;I-piece 2 X	
	!BYTE	0	;J-piece 2 X
	!BYTE	0	;L-piece 2 X
	!BYTE	2	;O-piece 2 X
	!BYTE	2	;S-piece 2 X
	!BYTE	0	;T-piece 2 X
	!BYTE	1	;Z-piece 2 X
BRICK_CHART_BY:
	!BYTE	1	;I-piece 2 Y
	!BYTE	1	;J-piece 2 Y
	!BYTE	1	;L-piece 2 Y
	!BYTE	0	;O-piece 2 Y
	!BYTE	0	;S-piece 2 Y
	!BYTE	1	;T-piece 2 Y
	!BYTE	0	;Z-piece 2 Y
BRICK_CHART_CX:
	!BYTE	2	;I-piece 3 X	
	!BYTE	1	;J-piece 3 X
	!BYTE	1	;L-piece 3 X
	!BYTE	1	;O-piece 3 X
	!BYTE	0	;S-piece 3 X
	!BYTE	1	;T-piece 3 X
	!BYTE	1	;Z-piece 3 X
BRICK_CHART_CY:
	!BYTE	1	;I-piece 3 Y	
	!BYTE	1	;J-piece 3 Y
	!BYTE	1	;L-piece 3 Y
	!BYTE	1	;O-piece 3 Y
	!BYTE	1	;S-piece 3 Y
	!BYTE	1	;T-piece 3 Y
	!BYTE	1	;Z-piece 3 Y
BRICK_CHART_DX:
	!BYTE	3	;I-piece 4 X	
	!BYTE	2	;J-piece 4 X
	!BYTE	2	;L-piece 4 X
	!BYTE	2	;O-piece 4 X
	!BYTE	1	;S-piece 4 X
	!BYTE	2	;T-piece 4 X
	!BYTE	2	;Z-piece 4 X
BRICK_CHART_DY:
	!BYTE	1	;I-piece 4 Y	
	!BYTE	1	;J-piece 4 Y
	!BYTE	1	;L-piece 4 Y
	!BYTE	1	;O-piece 4 Y
	!BYTE	1	;S-piece 4 Y
	!BYTE	1	;T-piece 4 Y
	!BYTE	1	;Z-piece 4 Y
BRICK_CHART_COLOR:
	!BYTE	$A3	;I-piece (CYAN)	
	!BYTE	$A6	;J-piece (BLUE)
	!BYTE	$A9	;L-piece (ORANGE)
	!BYTE	$A7	;O-piece (YELLOW)
	!BYTE	$A5	;S-piece (GREEN)
	!BYTE	$A4	;T-piece (PURPLE)
	!BYTE	$A2	;Z-piece (RED)

	;     I J L O S T Z
ROTATION_AX:
	!BYTE 4,4,2,2,3,3,4	;1ST ROTATION
	!BYTE 3,2,0,2,1,1,2	;2ND ROTATION
	!BYTE 0,0,2,2,1,1,0	;3ND ROTATION
	!BYTE 1,2,4,2,3,3,2	;4TH ROTATION
ROTATION_AY:
	!BYTE 1,2,4,2,3,3,2	;1ST ROTATION
	!BYTE 4,4,2,2,3,3,4	;2ND ROTATION
	!BYTE 3,2,0,2,1,1,2	;3ND ROTATION
	!BYTE 0,0,2,2,1,1,0	;4TH ROTATION
ROTATION_BX:
	!BYTE 3,3,3,2,2,3,3	;1ST ROTATION
	!BYTE 2,3,3,2,0,3,1	;2ND ROTATION
	!BYTE 1,1,1,2,2,1,1	;3ND ROTATION
	!BYTE 2,1,1,2,4,1,3	;4TH ROTATION
ROTATION_BY:
	!BYTE 2,1,1,2,4,1,3	;1ST ROTATION
	!BYTE 3,3,3,2,2,3,3	;2ND ROTATION
	!BYTE 2,3,3,2,0,3,1	;3ND ROTATION
	!BYTE 1,1,1,2,2,1,1	;4TH ROTATION
ROTATION_CX:
	!BYTE 2,2,2,2,3,2,2	;1ST ROTATION
	!BYTE 1,2,2,2,3,2,2	;2ND ROTATION
	!BYTE 2,2,2,2,1,2,2	;3ND ROTATION
	!BYTE 3,2,2,2,1,2,2	;4TH ROTATION
ROTATION_CY:
	!BYTE 3,2,2,2,1,2,2	;1ST ROTATION
	!BYTE 2,2,2,2,3,2,2	;2ND ROTATION
	!BYTE 1,2,2,2,3,2,2	;3ND ROTATION
	!BYTE 2,2,2,2,1,2,2	;4TH ROTATION
ROTATION_DX:
	!BYTE 1,1,1,2,2,1,1	;1ST ROTATION
	!BYTE 0,1,1,2,2,1,1	;2ND ROTATION
	!BYTE 3,3,3,2,2,3,3	;3ND ROTATION
	!BYTE 4,3,3,2,2,3,3	;4TH ROTATION
ROTATION_DY:
	!BYTE 4,3,3,2,2,3,3	;1ST ROTATION
	!BYTE 1,1,1,2,2,1,1	;2ND ROTATION
	!BYTE 0,1,1,2,2,1,1	;3ND ROTATION
	!BYTE 3,3,3,2,2,3,3	;4TH ROTATION

SET_PLAYFIELD_SIZE:
	LDA	FIELD_WIDTH
	SEC
	SBC	#10
	LSR	;DIVIDE BY 2
	TAX
	LDA	PFCHART,X
	STA	LEFT_START
	RTS
PFCHART	!BYTE 30,28,26,24

CLEAR_SCREEN:
	LDY	#0
	LDA	#%00010001
	STA	VERA_H
CSC0:	TYA	
	CLC
	ADC	#$B0
	STA	VERA_M
	LDX	#0
	LDA	#0
	STA	VERA_L
CSC1:	LDA	#32	;SPACE
	STA	VERA_DATA
	LDA	#$01	;WHITE ON BLACK
	STA	VERA_DATA
	INX
	CPX	#40
	BNE	CSC1
	INY
	CPY	#30
	BNE	CSC0
	RTS

ANIMATE_SCREEN_OPENING:
	LDA	#$B5
	STA	TY
	JSR	BORDER_SET_LINE
	JSR	MAIN_BORDER_TOPBOT
	LDA	#$CA
	STA	TY
	JSR	BORDER_SET_LINE
	JSR	MAIN_BORDER_TOPBOT
	LDA	#$B6
	STA	TY
ASO1:	JSR	BORDER_SET_LINE
	JSR	MAIN_BORDER_CENTER
	INC	TY
	LDA	TY
	CMP	#$CA
	BNE	ASO1
	RTS

BORDER_SET_LINE:
	LDA	#%00010001
	STA	VERA_H
	LDA	TY
	STA	VERA_M
	LDA	LEFT_START
	DEC	
	DEC
	STA	VERA_L
	RTS

MAIN_BORDER_TOPBOT:
	LDA	#128
	STA	VERA_DATA
	LDA	#$A1	;WHITE
	STA	VERA_DATA
	LDX	FIELD_WIDTH
MBT1:	LDA	#130
	STA	VERA_DATA
	LDA	#$AC	;GRAY
	STA	VERA_DATA
	DEX
	CPX	#00
	BNE	MBT1
	LDA	#128
	STA	VERA_DATA
	LDA	#$A1	;WHITE
	STA	VERA_DATA
	RTS

MAIN_BORDER_CENTER:
	LDA	#133
	STA	VERA_DATA
	LDA	#$AC	;GRAY
	STA	VERA_DATA
	LDA	VERA_L
	CLC
	ADC	FIELD_WIDTH
	ADC	FIELD_WIDTH
	STA	VERA_L
	LDA	#133
	STA	VERA_DATA
	LDA	#$AC	;GRAY
	STA	VERA_DATA
	RTS

CLEAR_PLAYFIELD:
	;first clear the screen data
	LDA	#%00010001
	STA	VERA_H
	LDY	#0
CPF0:	TYA
	CLC
	ADC	#$B6
	STA	VERA_M
	LDA	LEFT_START
	STA	VERA_L
	LDX	#0
CPF1:	LDA	#135	;BLOCK CHAR
	STA	VERA_DATA
	LDA	#$AA	;BLACK ON BLACK
	STA	VERA_DATA
	INX
	CPX	FIELD_WIDTH
	BNE	CPF1
	INY
	CPY	#20
	BNE	CPF0
	;now clear the playfield buffer
	LDX	#0
CPF2:	LDA	#$AA
	STA	PLAYFIELD,X
	INX	
	CPX	#00
	BNE	CPF2
CPF3:	LDA	#$AA
	STA	PLAYFIELD+256,X
	INX
	CPX	#64
	BNE	CPF3	
	RTS

PAUSE_GAME:
	JSR	PLAY_MENU_SELECT
	LDA	#%00010001
	STA	VERA_H
	LDA	#$C0
	STA	VERA_M
	LDA	#32
	STA	VERA_L
	LDX	#0
PG0:	LDA	PAUSED_TEXT,X
	STA	VERA_DATA
	LDA	#$A1	;white
	STA	VERA_DATA
	INX
	CPX	#8
	BNE	PG0
	;now pause for 1 second
	LDA	#60
	STA	COUNTDOWN
PG1:	LDA	COUNTDOWN
	CMP	#0
	BNE	PG1
	;now wait for a key
	JSR	CLEAR_KEYBOARD_BUFFER
PG2:	LDA	#1		;JOY 1
	JSR	$FF56		;JOYSTICK GET
	AND	#%00010000
	CMP	#%00000000
	BNE	PG3:
	JMP	PG4
PG3:	JSR	GETIN
	CMP	#0
	BEQ	PG2
PG4:	JSR	PLAY_MENU_SELECT
	JSR	COPY_BUFFER_TO_SCREEN
	RTS

PAUSED_TEXT:
	!SCR	"paused.."

SETUP_VERA:
	;Configure scale and geometry
	LDA	#64
	STA	$9F2A	;VERA H-SCALE
	STA	$9F2B	;VERA V-SCALE
	SEI
	LDA	#%00000010
	STA	$9F25	;enable DC select
	LDA	#0
	STA	$9F29	;H-START
	LDA	#160	
	STA	$9F2A	;H-STOP
	LDA	#0	
	STA	$9F2B	;V-START
	LDA	#240	
	STA	$9F2C	;V-STOP	
	LDA	#%00000000
	STA	$9F25	;disable DC select
	CLI
	; setup the graphics modes.
SETV1:	LDA	#3
	STA	$9F31	;move palette for layer 0 (bitmap)
	LDA	#96
	STA	$9F34	;set layer 1 (text mode)
	LDA	#216	;(multiples of 512)
	STA	$9F35	; set text mode vram base address to $1,B000
	LDA	#248	;(multiples of 2048, only top 6 bits)
	STA	$9F36	;SET character bitmap vram location to $1,F000
	;NOW COPY MODIFIED PALETTE
	LDA	#%00010001
	STA	VERA_H
	LDA	#$FA
	STA	VERA_M
	LDA	#00
	STA	VERA_L
	LDX	#0
SETV3:	LDA	PALETTE,X
	STA	VERA_DATA
	INX
	CPX	#32
	BNE	SETV3
	RTS

;This is the palette used for text mode.  The graphics
;layer loads in its own palette for each background,
;which does not affect this palette.
PALETTE:
	!BYTE	0	;COLOR 0 (7:4 GREEN) (3:0) BLUE
	!BYTE	0	;COLOR 0 (RED)
	!BYTE	255	;COLOR 1 (7:4 GREEN) (3:0) BLUE
	!BYTE	15	;COLOR 1 (RED)
	!BYTE	34	;COLOR 2 (7:4 GREEN) (3:0) BLUE
	!BYTE	15	;COLOR 2 (RED)
	!BYTE	190	;COLOR 3 (7:4 GREEN) (3:0) BLUE
	!BYTE	0	;COLOR 3 (RED)
	!BYTE	15	;COLOR 4 
	!BYTE	15	;COLOR 4 
	!BYTE	160	;COLOR 5 (7:4 GREEN) (3:0) BLUE
	!BYTE	0	;COLOR 5 (RED)
	!BYTE	44	;COLOR 6 (7:4 GREEN) (3:0) BLUE
	!BYTE	2	;COLOR 6 (RED)
	!BYTE	244	;COLOR 7 (7:4 GREEN) (3:0) BLUE
	!BYTE	15	;COLOR 7 (RED)
	!BYTE	128	;COLOR 8 (7:4 GREEN) (3:0) BLUE
	!BYTE	15	;COLOR 8 (RED)
	!BYTE	96	;COLOR 9 (7:4 GREEN) (3:0) BLUE
	!BYTE	6	;COLOR 9 (RED)
	!BYTE	0	;COLOR 10 EXTRA BLACK HERE BECAUSE
	!BYTE	0	;COLOR 10 0 IS TRANSPARENT
	!BYTE	85	;COLOR 11 (7:4 GREEN) (3:0) BLUE
	!BYTE	5	;COLOR 11 (RED)
	!BYTE	136	;COLOR 12 (7:4 GREEN) (3:0) BLUE
	!BYTE	8	;COLOR 12 (RED)
	!BYTE	248	;COLOR 13 (7:4 GREEN) (3:0) BLUE
	!BYTE	8	;COLOR 13 (RED)
	!BYTE	143	;COLOR 14 (7:4 GREEN) (3:0) BLUE
	!BYTE	8	;COLOR 14 (RED)
	!BYTE	204	;COLOR 15 (7:4 GREEN) (3:0) BLUE
	!BYTE	12	;COLOR 15 (RED)

DISPLAY_IMAGE:
	;Disable screen layers
	LDA	$9F29
	AND	#%00000011
	;ORA	#%00110000
	STA	$9F29
	;first copy palette
DISP2:	LDA	#%00010001
	STA	VERA_H
	LDA	#$FA
	STA	VERA_M
	LDA	#96
	STA	VERA_L
	LDX	#0
SETP3:	LDA	RLE_DATA,X
	STA	VERA_DATA
	INX
	CPX	#32
	BNE	SETP3

	;prepare for decompress
	LDA	#$28
	STA	VERA_L
	LDA	#00
	STA	VERA_DATA
	STA	VERA_DATA
	LDA	#$0
	STA	VERA_L
	LDA	#$20		;set vram address to $2000
	STA	VERA_M
	LDA	#%00010000	;set increment to 1
	STA	VERA_H
	LDA	#<RLE_DATA+32
	STA	SOURCE_L
	LDA	#>RLE_DATA+32
	STA	SOURCE_H
	LDY	#0
	STY	STEP
	STY	EOF
	
;This is the main loop of the decompression routine.
DECOMPRESS:
	JSR	GET_NEXT_SOURCE_BYTE
	;Now split up byte into 4 bits for repeat, 4 bits color
	LDA	SOURCE_BYTE
	AND	#%11110000
	LSR
	LSR
	LSR
	LSR
	STA	REPEAT
	LDA	SOURCE_BYTE
	AND	#%00001111
	STA	COLOR
	;now examine repeat number
	LDA	REPEAT
	CMP	#15	;15 means load in another byte for repeat data
	BNE	REPEAT_LOOP
	JSR	GET_NEXT_SOURCE_BYTE
	LDA	SOURCE_BYTE
	CLC
	ADC	REPEAT
	STA	REPEAT

;At this point we have COLOR and REPEAT properly defined.
REPEAT_LOOP:
	JSR	PUSH_COLOR_TO_VERA
	LDA	VERA_M
	LDA	REPEAT
	CMP	#0
	BEQ	RL2
	DEC	REPEAT
	JMP	REPEAT_LOOP
RL2:	LDA	EOF
	CMP	#1
	BEQ	FINISHED
	JMP	DECOMPRESS
FINISHED:	
	;enable screen layers
	LDA	$9F29
	AND	#%00000011
	ORA	#%00110000
	STA	$9F29
	RTS

;This routine is in charge of pushing the next pixel to the vera.  Since
;we are using 4 BPP, we can't push anything to the vera until we have
;at least 2 pixels rendered.
PUSH_COLOR_TO_VERA:
	LDA	COLOR
	LDX	STEP
	CPX	#1
	BEQ	STEP2
STEP1:	ASL
	ASL
	ASL
	ASL	
	STA	OUTPUT
	INC	STEP
	RTS
STEP2:	ORA	OUTPUT
	STA	VERA_DATA
	LDA	#0
	STA	STEP
	RTS

;This routine simply reads in the next byte in the RLE data stream
;and then increments the source location by 1.
GET_NEXT_SOURCE_BYTE:
	LDA	(SOURCE_L),Y
	STA	SOURCE_BYTE
	INY
	CPY	#0
	BNE	GNS5
	INC	SOURCE_H
GNS5:	;now check if we are at EOF
	LDA	SOURCE_H
	CMP	EOF_H
	BNE	GNS6
	CPY	EOF_L
	BNE	GNS6
	LDA	#1
	STA	EOF
GNS6:	RTS

GENERATE_RANDOM_NUMBER:
 	LDA	RANDOM
	BEQ 	DOEOR ;added this
	ASL
	BCC	NOEOR
DOEOR:	EOR	#$1D
NOEOR:	STA	RANDOM
	RTS

;This routine loads in 8 custom characters
;into VRAM starting at #128 (located at $1,F400)
LOAD_NEWCHARS:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$F4
	STA	VERA_M
	LDA	#00
	STA	VERA_L
	LDX	#0
LDC1:	LDA	NEWCHARS,X
	STA	VERA_DATA
	INX
	CPX	#64
	BNE	LDC1	
	RTS	

GAME_OVER:
	JSR	ZSM_STOP
	LDA	#%00010001
	STA	VERA_H
	LDA	#$C0
	STA	VERA_M
	LDA	#30
	STA	VERA_L
	LDX	#0
DG0:	LDA	GAME_OVER_TEXT,X
	STA	VERA_DATA
	LDA	#$A1	;white
	STA	VERA_DATA
	INX
	CPX	#9
	BNE	DG0
	;now pause for 1 second
	LDA	#60
	STA	COUNTDOWN
DG1:	LDA	COUNTDOWN
	CMP	#0
	BNE	DG1
	;now wait for a key
	JSR	CLEAR_KEYBOARD_BUFFER
DG2:	LDA	#1		;JOY 1
	JSR	$FF56		;JOYSTICK GET
	CMP	#$FF
	BEQ	DG4		;any button pressed
	JMP	DG5
DG4:	JSR	GETIN
	CMP	#3
	BEQ	DG4
	CMP	#0
	BEQ	DG2
DG5:	JSR	CLEAR_SCREEN
	LDA	#30
	STA	COUNTDOWN
DG3:	LDA	COUNTDOWN
	CMP	#0
	BNE	DG3
	JMP	MAIN_MENU

GAME_OVER_TEXT:
	!SCR	"game over"

MAIN_MENU:
	LDA	#0
	STA	BG_NUMBER
	JSR	LOAD_PICTURE
	JSR	DISPLAY_IMAGE
	LDA	MUSIC_ON
	CMP	#0
	BEQ	MMA
	LDA	#$06
	LDY	#$A0
	LDX	#$00
	JSR	ZSM_START
MMA:	JSR	DISPLAY_LOGO
	JSR	DRAW_MENU
	JSR	DISPLAY_FIELD_WIDTH
	JSR	DISPLAY_SPEED
	JSR	DISPLAY_MUSIC
	JSR	DISPLAY_LEVEL
	JSR	DISPLAY_CONTROLS
	LDA	#60
	STA	COUNTDOWN
	STZ	TY
	JSR	HIGHLIGHT_MENU_LINE
	JSR	CLEAR_KEYBOARD_BUFFER
MM1:	JSR	ANIMATE_LOGO
	JSR	SHOW_CREDITS
	INC	RANDOM
	JSR	GETIN
	CMP	#0
	BEQ	SM1
	CMP	#$11	;cursor down
	BNE	MM2
	JSR	MENU_DOWN
	JMP	MM1
MM2:	CMP	#145	;cursor UP
	BNE	MM3
	JSR	MENU_UP
	JMP	MM1
MM3:	CMP	#13	;RETURN
	BNE	MM4
	JMP	EXECUTE
MM4:	CMP	#32	;space
	BNE	MM5
	JMP	EXECUTE
MM5:	JMP	MM1	
SM1:	;Now scan SNES controller
	LDA	COUNTDOWN2
	CMP	#0
	BEQ	SM2
	JMP	MM1
SM2:	;JSR	$FF53		;JOYSTICK SCAN	
	LDA	#1		;JOY 1
	JSR	$FF56		;JOYSTICK GET
	STA	SNES_L
	AND	#%00000100	;DPAD-DOWN
	CMP	#%00000000
	BNE	SM3
	JSR	MENU_DOWN
	LDA	#10
	STA	COUNTDOWN2
	JMP	MM1
SM3:	LDA	SNES_L
	AND	#%00001000	;DPAD-UP
	CMP	#%00000000
	BNE	SM4
	JSR	MENU_UP
	LDA	#10
	STA	COUNTDOWN2
SM4:	LDA	SNES_L
	AND	#%10000000	;B-BUTTON
	CMP	#%00000000
	BNE	SM5
	JMP 	EXECUTE
	JMP	MM1
SM5:	LDA	SNES_L
	AND	#%00010000	;B-BUTTON
	CMP	#%00000000
	BNE	SM6
	JMP 	START_GAME
SM6:	JMP	MM1

EXECUTE:
	JSR	PLAY_MENU_SELECT
	LDA	TY
	CMP	#0
	BNE	EXE2
	JSR	CLEAR_SCREEN
	JMP	START_GAME
EXE2:	CMP	#1
	BNE	EXE3
	JSR	CYCLE_WIDTH
	JMP	EXE7
EXE3:	CMP	#2
	BNE	EXE4
	JSR	CYCLE_LEVEL
	JMP	EXE7
EXE4:	CMP	#3
	BNE	EXE5
	JSR	CYCLE_CONTROLS
	JMP	EXE7
EXE5:	CMP	#4
	BNE	EXE6
	JSR	CYCLE_MUSIC
	JMP	EXE7
EXE6:	CMP	#5
	BNE	EXE7
	JSR	CYCLE_SPEED
EXE7:	LDA	#10
	STA	COUNTDOWN2
	JMP	MM1

CYCLE_CONTROLS:
	LDA	CONTROL
	EOR	#%00000001
	STA	CONTROL
DISPLAY_CONTROLS:
	LDA	#%00100001
	STA	VERA_H
	LDA	#$C1
	STA	VERA_M
	LDA	#42
	STA	VERA_L
	LDA	CONTROL
	CMP	#1	;0=const 1=prog
	BEQ	DSC2:
	LDA	#11
	STA	VERA_DATA
	LDA	#5
	STA	VERA_DATA
	LDA	#25
	STA	VERA_DATA
	LDA	#2
	STA	VERA_DATA
	RTS
DSC2:	LDA	#19	
	STA	VERA_DATA
	LDA	#14
	STA	VERA_DATA	
	LDA	#5
	STA	VERA_DATA
	LDA	#19
	STA	VERA_DATA
	RTS

CYCLE_LEVEL:
	INC	START_LEVEL
	LDA	START_LEVEL
	CMP	#12
	BNE	DISPLAY_LEVEL
	STZ	START_LEVEL	
DISPLAY_LEVEL:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$C0
	STA	VERA_M
	LDA	#42
	STA	VERA_L	
	LDX	START_LEVEL
	LDA	HEXCHART,X
	STA	VERA_DATA
	RTS

CYCLE_SPEED:
	LDA	PROG
	EOR	#%00000001
	STA	PROG

DISPLAY_SPEED:
	LDA	#%00100001
	STA	VERA_H
	LDA	#$C3
	STA	VERA_M
	LDA	#42
	STA	VERA_L
	LDA	PROG
	CMP	#1	;0=const 1=prog
	BEQ	CSP2:
	LDA	#3
	STA	VERA_DATA
	LDA	#15
	STA	VERA_DATA
	LDA	#14
	STA	VERA_DATA
	LDA	#19
	STA	VERA_DATA
	LDA	#20
	STA	VERA_DATA
	RTS
CSP2:	LDA	#16	
	STA	VERA_DATA
	LDA	#18
	STA	VERA_DATA	
	LDA	#15
	STA	VERA_DATA
	LDA	#7
	STA	VERA_DATA
	LDA	#32
	STA	VERA_DATA
	RTS

CYCLE_MUSIC:
	LDA	MUSIC_ON
	CMP	#0
	BEQ	CYMU1
	;turn music off	
	STZ	MUSIC_ON
	JSR	ZSM_STOP
	JMP	DISPLAY_MUSIC
CYMU1:	;Turn music on
	LDA	#1
	STA	MUSIC_ON
	LDA	#$06
	LDY	#$A0
	LDX	#$00
	JSR	ZSM_START

DISPLAY_MUSIC:
	LDA	#%00100001
	STA	VERA_H
	LDA	#$C2
	STA	VERA_M
	LDA	#44
	STA	VERA_L
	LDA	MUSIC_ON
	CMP	#0
	BNE	CYMU2
	LDA	#6
	STA	VERA_DATA
	STA	VERA_DATA
	RTS
CYMU2:	LDA	#14
	STA	VERA_DATA
	LDA	#32
	STA	VERA_DATA
	RTS

CYCLE_WIDTH:
	LDA	FIELD_WIDTH
	CMP	#16
	BEQ	CW1
	INC	FIELD_WIDTH
	INC	FIELD_WIDTH
	JMP	DISPLAY_FIELD_WIDTH
CW1:	LDA	#10
	STA	FIELD_WIDTH
DISPLAY_FIELD_WIDTH:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$BF
	STA	VERA_M
	LDA	#44
	STA	VERA_L
	LDA	FIELD_WIDTH
	CMP	#10
	BNE	CW4
	LDA	#48	;0
	JMP	CW10	
CW4:	CMP	#12
	BNE	CW5
	LDA	#50	;2
	JMP	CW10
CW5:	CMP	#14
	BNE	CW6
	LDA	#52	;4
	JMP	CW10
CW6:	LDA	#54	;6
CW10:	STA	VERA_DATA
	RTS

MENU_DOWN:
	LDA	TY
	CMP	#5
	BEQ	MED1
	JSR	PLAY_MENU_BEEP
	JSR	DELIGHT_MENU_LINE
	INC	TY
	JSR	HIGHLIGHT_MENU_LINE
MED1:	RTS

MENU_UP:
	LDA	TY
	CMP	#0
	BEQ	MEU1
	JSR	PLAY_MENU_BEEP
	JSR	DELIGHT_MENU_LINE
	DEC	TY
	JSR	HIGHLIGHT_MENU_LINE
MEU1:	RTS

CALC_MENU_LINE:
	LDA	#%00100001
	STA	VERA_H
	LDA	#$BE
	CLC
	ADC	TY
	STA	VERA_M
	LDA	#27
	STA	VERA_L
	LDX	#0
	RTS

DO_MENU_LINE:
HML1:	STA	VERA_DATA
	INX	
	CPX	#14
	BNE	HML1
	RTS	

HIGHLIGHT_MENU_LINE:
	JSR	CALC_MENU_LINE
	LDA	#$1A
	JMP	DO_MENU_LINE

DELIGHT_MENU_LINE:
	JSR	CALC_MENU_LINE
	LDA	#$A6
	JMP	DO_MENU_LINE

DRAW_MENU:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$BD
	STA	VERA_M
	LDA	#24
	STA	VERA_L
	LDY	#0
	STY	TY	
	LDX	#0
DRM0:	LDY	#0
DRM1:	LDA	MENU_TEXT,X
	STA	VERA_DATA
	CMP	#128
	BCC	DRM2
	LDA	#$A5	;green on black
	JMP	DRM3
DRM2:	LDA	#$A6	;blue on black
DRM3:	STA	VERA_DATA
	INX
	INY
	CPY	#16
	BNE	DRM1
	INC	VERA_M
	LDA	#24
	STA	VERA_L
	INC	TY
	LDA	TY
	CMP	#8
	BNE	DRM0	
	RTS
	
DISPLAY_LOGO:
	LDA	#%00010001
	STA	VERA_H
	LDA	#$B2
	STA	VERA_M
	STZ	TY
	LDY	#0
DILA:	;PAUSE .25 SECONDS
	LDA	#15
	STA	COUNTDOWN
DILB:	LDA	COUNTDOWN
	CMP	#0
	BNE	DILB
	;DRAW NEXT LINE OF LOGO
	LDX	#0
	LDA	#12
	STA	VERA_L
DIL0:	LDA	#135	;block char
	STA	VERA_DATA
	LDA	LOGO_DATA,Y
	CMP	#0
	BNE	DIL1
	LDA	#$00
	JMP	DIL2
DIL1:	LDA	#$A7
DIL2:	STA	VERA_DATA
	INX
	INY
	CPX	#27
	BNE	DIL0
	INC	VERA_M
	INC	TY
	LDA	TY
	CMP	#5
	BNE	DILA
	;PAUSE AGAIN.
	LDA	#30
	STA	COUNTDOWN
DILC:	LDA	COUNTDOWN
	CMP	#0
	BNE	DILC
	RTS

SHOW_CREDITS:
	LDA	CREDITS_TIMER
	CMP	#0
	BEQ	CRED2
	RTS
CRED2:	LDA	#2
	STA	CREDITS_TIMER
	LDA	#%00010001
	STA	VERA_H
	LDA	#$C8
	STA	VERA_M
	LDA	#18
	STA	VERA_L
	LDX	CREDITS_TIMER2
	LDA	CREDITS_CHART,X
	TAX	
	LDY	#0
DIL3:	LDA	CREDITS_TEXT,X
	STA	VERA_DATA
	LDA	#$01
	STA	VERA_DATA
	INX
	INY
	CPY	#22
	BNE	DIL3
	INC	CREDITS_TIMER2
	LDA	CREDITS_TIMER2
	CMP	#3
	BNE	CRED3
	STZ	CREDITS_TIMER2
CRED3:	RTS
CREDITS_CHART:
	!BYTE	0,22,44
CREDITS_TEXT:
	!SCR	"coded by the 8-bit guy"
	!SCR	"  zsound by zerobyte  "	
	!SCR	"  music by nicco1690  "

ANIMATE_LOGO:
	LDA	COUNTDOWN
	CMP	#0
	BEQ	ANL1
	RTS
ANL1:	LDA	#60
	STA	COUNTDOWN
	DEC	CREDITS_TIMER
	LDA	#%00000001
	STA	VERA_H
	LDA	#$B2
	STA	VERA_M
ANLA	LDA	#13
	STA	VERA_L
ANLB:	LDA	VERA_DATA
	CMP	#$00	;black on black
	BEQ	ANL3
	CMP	#$A7	;yellow
	BNE	ANL2
	LDA	#$A1	
ANL2:	INC
	STA	VERA_DATA	
ANL3:	INC	VERA_L
	INC	VERA_L
	LDA	VERA_L
	CMP	#67
	BNE	ANLB
	INC	VERA_M
	LDA	VERA_M
	CMP	#$B7
	BNE	ANLA
	RTS

;The Tile music is loaded into high RAM and stays there the
;entire time.
LOAD_TITLE_MUSIC:
	LDA	#6
	STA	$0000	;set bank 0
	LDA	#11	;filename-length
	LDX	#<MUSIC_TITLE_FILENAME
	LDY	#>MUSIC_TITLE_FILENAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$08
	LDY	#$02
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDX	#$00
	LDY	#$A0	;load into $A000
	LDA	#$00
	JSR	$FFD5	;LOAD FILE A=0 FOR LOAD X/Y=LOAD ADDRESS
	LDA	#$02
	JSR	$FFC3	;CLOSE FILE
	RTS

;The end-game music is loaded into high ram, but is replaced 
;with a new song when the level changes.
LOAD_GAME_MUSIC:
	;adjust filename
	LDA	MUSIC_SCORE
	CLC
	ADC	#48	;start of PETSCII numbers
	STA	MUSIC_FILENAME+6	
	;Now load file
	LDA	#12
	STA	$0000	;set bank 0
	LDA	#11	;filename-length
	LDX	#<MUSIC_FILENAME
	LDY	#>MUSIC_FILENAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$08
	LDY	#$02
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDX	#$90
	LDY	#$BA	;load into $BA90
	LDA	#$00
	JSR	$FFD5	;LOAD FILE A=0 FOR LOAD X/Y=LOAD ADDRESS
	LDA	#$02
	JSR	$FFC3	;CLOSE FILE
	RTS

;Sound effects are combined into a single file (see database comments at
;end of source for specifics on that) and loaded into high-RAM
LOAD_SFX:
	LDA	#1
	STA	$0000	;set bank 0
	LDA	#10	;filename-length
	LDX	#<SFX_FILENAME
	LDY	#>SFX_FILENAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$08
	LDY	#$02
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDX	#$00
	LDY	#$A0	;load into $A000
	LDA	#$00
	JSR	$FFD5	;LOAD FILE A=0 FOR LOAD X/Y=LOAD ADDRESS
	LDA	#$02
	JSR	$FFC3	;CLOSE FILE
	RTS

;Pictures are loaded into low-RAM.  And then decompressed into VRAM
LOAD_PICTURE:
	LDA	BG_NUMBER
	CLC
	ADC	#48	;start of PETSCII numbers
	STA	BG_FILENAME+2	
	LDA	#7	;filename-length
	LDX	#<BG_FILENAME
	LDY	#>BG_FILENAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$08
	LDY	#$00
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDX	#<RLE_DATA
	LDY	#>RLE_DATA	
	LDA	#$00
	JSR	$FFD5	;LOAD FILE A=0 FOR LOAD X/Y=LOAD ADDRESS
	STY	EOF_H
	STX	EOF_L	;store end-of-file location.
	LDA	#$02
	JSR	$FFC3	;CLOSE FILE
	RTS

PLAY_CLEAR_LINE:
	LDA	LINES_FOUND
	CMP	#4
	BEQ	PCL2
	LDA	#2	;BANK 2
	LDX	#$01
	LDY	#$B8	;load from $B801
	JSR	PCM_TRIGGER_DIGI
	RTS
PCL2:	LDA	#1	;BANK 1
	LDX	#$00
	LDY	#$A0	;load from $B801
	JSR	PCM_TRIGGER_DIGI
	RTS
	
PLAY_LAY_BRICK:
	LDA	#4	;BANK 4
	LDX	#$4C
	LDY	#$A8	;load from $A84c
	JSR	PCM_TRIGGER_DIGI
	RTS
PLAY_MENU_BEEP:
	LDA	#4	;BANK 4
	LDX	#$F1
	LDY	#$B1	;load from $B1F1
	JSR	PCM_TRIGGER_DIGI
	RTS
PLAY_MENU_SELECT:
	LDA	#4	;BANK 4
	LDX	#$4D
	LDY	#$B7	;load from $B74D
	JSR	PCM_TRIGGER_DIGI
	RTS
PLAY_ROTATE_LEFT:
	LDA	#5	;BANK 5
	LDX	#$84
	LDY	#$A2	;load from $A284
	JSR	PCM_TRIGGER_DIGI
	RTS
PLAY_ROTATE_RIGHT:
	LDA	#5	;BANK 5
	LDX	#$59
	LDY	#$AA	;load from $AA59
	JSR	PCM_TRIGGER_DIGI
	RTS

;The following chart is just reserved space for the playfield buffer
;(so that you don't need to read screen RAM to know where things are)
;it is 16 bytes wide to make it easy to calculate and to allow for
;adjustable playfield size.  This should probably be moved outside 
;of code-space.

PLAYFIELD:
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
	!BYTE	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA

NEWCHARS:
	!BYTE	%00000000	;CHAR 128
	!BYTE	%01111110	;CORNER PIECE OF PLAYFIELD
	!BYTE	%01111110
	!BYTE	%01100110
	!BYTE	%01100110
	!BYTE	%01111110
	!BYTE	%01111110
	!BYTE	%00000000

	!BYTE	%00000000	;CHAR 129
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000

	!BYTE	%00000000	;CHAR 130
	!BYTE	%11111111	;PLAYFIELD TOP/BOTTOM
	!BYTE	%00111111
	!BYTE	%11001111
	!BYTE	%11110011
	!BYTE	%11111100
	!BYTE	%11111111
	!BYTE	%00000000

	!BYTE	%00000000	;CHAR 131
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000

	!BYTE	%00000000	;CHAR 132
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000

	!BYTE	%01111010	;CHAR 133
	!BYTE	%01111010	;PLAYFIELD LEFT/RIGHT
	!BYTE	%01110110
	!BYTE	%01110110
	!BYTE	%01101110
	!BYTE	%01101110
	!BYTE	%01011110
	!BYTE	%01011110

	!BYTE	%00000000	;CHAR 134
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000
	!BYTE	%00000000

	!BYTE	%00000000	;CHAR 135
	!BYTE	%01111111	;Used to make bricks
	!BYTE	%01000001
	!BYTE	%01111101
	!BYTE	%01111101
	!BYTE	%01111101
	!BYTE	%01111101
	!BYTE	%01111111

MENU_TEXT:
	!BYTE	128,130,130,130,130,130,130,130
	!BYTE	130,130,130,130,130,130,130,128	
	!SCR	133,"  start game  ",133
	!SCR	133,"width = 1     ",133
	!SCR	133,"level =       ",133
	!SCR	133,"cntrl =       ",133
	!SCR	133,"music = o     ",133
	!SCR	133,"speed =       ",133
	!BYTE	128,130,130,130,130,130,130,130
	!BYTE	130,130,130,130,130,130,130,128

NEXT_AREA_DATA:
	!BYTE	128,130,130,130,130,128
	!SCR	133,"next",133
	!BYTE	133,135,135,135,135,133
	!BYTE	133,135,135,135,135,133
	!BYTE	128,130,130,130,130,128

SCORE_AREA_DATA:
	!BYTE	128,130,130,130,130,130,128
	!SCR	133,"score",133
	!SCR	133,"     ",133
	!SCR	133,"lines",133
	!SCR	133,"     ",133
	!BYTE	128,130,130,130,130,130,128

;26x5 character title logo.
LOGO_DATA:
	!BYTE	1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,1,1
	!BYTE	0,1,0,0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0
	!BYTE	0,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,1,0,1,1,1
	!BYTE	0,1,0,0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1
	!BYTE	0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,1,1

RLE_DATA:
;!BINARY "bg16.rle"	;CONTAINS RLE ENCODED GRAPHICS
EOF_LOCATION:

;The way the RLE encoding works is like this:
;Only a 4-bit (16 color) value is available for the color itslef, which is bits 0-3
;Bit 4-7 contain the number of repeats for that color (0-15)
;If the repeat is 15, then the second byte after will also contain a number from 0 to 255 which is added to the ;repeat count.

;IMAGES USED
;BG0.RLE - Title image, atom and lasers
;BG1.RLE - inductors
;BG2.RLE - circuit board
;BG3.RLE - Vacuum tubes
;BG4.RLE - Electric motor
;B55.RLE - photons
;B56.RLE - light bulbs
;B57.RLE - iceberg
;B58.RLE - space station
;B59.RLE - asteroids

;SOUND DATABASE
;BANK 1 - $A000 - CLEAR-4-LINES.ZCM 	SIZE=$3801
;BANK 2 - $B801 - CLEAR_LINE.ZCM		SIZE=$304B
;BANK 4 - $A84C - LAY_BRICK.ZCM		SIZE=$09A5
;BANK 4 - $B1F1 - MENU_BEEP.ZCM		SIZE=$055C
;BANK 4 - $B74D - MENU_SELECT.ZCM		SIZE=$0B37
;BANK 5 - $A284 - ROTATE_LEFT.ZCM		SIZE=$07D5
;BANK 5 - $AA59 - ROTATE_RIGHT.ZCM		SIZE=$0992

;HIGHRAM DATABASE
;BANK 00 - For kernal use
;BANK 01-05 - For sound effects
;BANK 06 - music




	